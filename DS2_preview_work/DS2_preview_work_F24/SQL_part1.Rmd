---
title: "Ch 15 from Modern Data Science with R"
subtitle: "Database querying using SQL"
output:
  pdf_document:
    fig_height: 3
    fig_width: 4.5
  html_document: default
  word_document: default
editor_options: 
  chunk_output_type: console
---

```{r, setup, include = FALSE}
# Initial packages required (we'll be adding more)
library(tidyverse)
library(mdsr)      # package associated with our MDSR book
```

In this chapter, we will explore approaches for working with data sets that are larger than what we've been exploring so far; for example, they will fit on a personal computer’s hard disk, but not necessarily in its memory.  Thankfully, a venerable solution for retrieving what we'll call medium-sized data from a database has been around since the 1970s: SQL (structured query language). Database management systems implementing SQL provide a ubiquitous architecture for storing and querying data that is relational in nature.  The wide deployment of SQL makes it a “must-know” tool for data scientists.


### Section 15.1: From dplyr to SQL

Recall the `flights` data from the nycflights13 package that we encountered in Data Science 1.  Even though that data seemed large (336776 x 19), since it only involves the year 2013 and 3 origin airports in the NYC area, it's really somewhat small by database standards, even if we consider the related data sets from the nycflights13 package (`airports`, `carriers`, etc.). 

However, if we consider additional years and origin airports, the `flights` data frame can become very large very quickly.  Going back to 1987, there are more than 169 million individual flights -- each comprising a different row in this table. These data occupy nearly 20 gigabytes as CSVs and thus are problematic to store in a personal computer’s memory.  Instead, one strategy is to write these data to disk and use a querying language to access only those rows that interest us.  The authors of MDSR created the `dbConnect_scidb()` function to provide a connection to the airlines database that lives on a remote MySQL server that they set up ahead of time; this connection is stored as the object `db`.  The tbl() function from `dplyr` maps the `flights` table in that `airlines` database to an object in R, in this case also called `flights`. The same is done for the `carriers` table.

```{r}
library(nycflights13)
old_flights <- flights
class(old_flights)
old_flights
table(old_flights$year)
table(old_flights$origin)

db <- dbConnect_scidb("airlines")
flights <- tbl(db, "flights")
carriers <- tbl(db, "carriers")

class(flights)
dim(flights)
```

Note that while we can use the `flights` and `carriers` objects as if they were data frames, they are not, in fact, data.frames.  Rather, they have class `tbl_MariaSQLConnection`, and more generally, `tbl_sql`. A `tbl` is a special kind of object created by `dplyr` that behaves similarly to a data.frame.  This allows `dplyr` to interact with these tbls as if they were data.frames in our R session -- a powerful and convenient illusion!  Therefore, we can use our usual `dplyr` verbs to, for example, retrieve the top on-time carriers with at least 100 flights arriving at JFK in September 2016:

```{r}
q <- flights |>
  filter(
    year == 2016 & month == 9, 
    dest == "JFK"
  ) |>
  inner_join(carriers, by = c("carrier" = "carrier")) |>
  group_by(name) |>
  summarize(
    N = n(), 
    pct_ontime = sum(arr_delay <= 15) / n()
  ) |>
  filter(N >= 100) |>
  arrange(desc(pct_ontime))
head(q, 4)
```

What is actually happening is that `dplyr` translates our pipeline into SQL.  We can see the translation by passing the pipeline through the `show_query()` function.  `dplyr` automatically translate our R code into SQL anytime we're using an object of class `tbl_sql`.

```{r}
show_query(q)
```

Here is what that SQL query would look like if we wrote it from scratch in a more readable format:

```{r, eval = FALSE}
SELECT 
  c.name,
  SUM(1) AS N, 
  SUM(arr_delay <= 15) / SUM(1) AS pct_ontime
FROM flights AS f
JOIN carriers AS c ON f.carrier = c.carrier
WHERE year = 2016 AND month = 9
  AND dest = 'JFK'
GROUP BY name 
HAVING N >= 100
ORDER BY pct_ontime DESC
LIMIT 0,4;
```


**PAUSE** List all of the parallels you see between our R code and our SQL query.  If you need a hint, you can use the `translate_sql` function in the `dbplyr` package.  

```{r}
library(dbplyr)
translate_sql(
  mean(arr_delay, na.rm = TRUE),
  con = db
)
```


When using `dplyr` with a `tbl_sql` backend, one must be careful to use expressions that SQL can understand.  See the example below involving `paste0`, which is not recoginized by SQL.  This is just one more reason why it is important to know SQL on its own and not rely entirely on the dplyr front-end (as wonderful as it is).

```{r, eval = FALSE}
# Store the paste0 function as my_paste.  This function pastes several
#   strings together into a single string.
my_paste <- paste0

# Note my_paste is not recognized and translated - it passes straight through
translate_sql(
  my_paste("this", "is", "a", "string"),
  con = db
)

# This throws an error because dplyr code is translated to SQL because 
#   carriers is a tbl_sql object, but there is no translation for my_paste
carriers |>
  mutate(name_code = my_paste(name, "(", carrier, ")"))

# Solution 1: replace my_paste with its SQL equivalent
carriers |>
  mutate(name_code = CONCAT(name, "(", carrier, ")"))

# Solution 2: first pull the carrier data into R using collect(), which
#   breaks the connection to the MySQL server and returns a data.frame
carriers |>
  collect() |>
  mutate(name_code = my_paste(name, "(", carrier, ")"))
```


### Section 15.2: Flat-file databases

Be able to describe the difference between flat-file databases and relational databases, along with limitations of flat-files databases.


### Section 15.3: The SQL universe

Become familiar with major implementations of SQL.  We will focus on MySQL.


### Section 15.4: The SQL data manipulation language

One way to run SQL queries from within Rmd files: place the lines in a `dbGetQuery()` function.  However, this only works for certain short SELECT queries.  If you get the error message "Error: MySQL server has gone away [2006]", you'll have to reconnect with the SQL server using `db <- dbConnect_scidb("airlines")`.

```{r}
library(DBI)

dbGetQuery(db,'
  SHOW TABLES;
')

dbGetQuery(db,'
  DESCRIBE airports;
')

dbGetQuery(db,'
  SELECT year, month, day, dep_time, sched_dep_time, dep_delay, origin
  FROM flights 
  LIMIT 0, 10;
')

# every query needs SELECT and FROM, so just use * if you want every column
dbGetQuery(db,'
  SELECT * FROM flights 
  LIMIT 0, 10;
')
```

---
title: "Simulating the ttest"
output:
  pdf_document: default
  html_document:
    df_print: paged
execute:
  echo: true
  warning: false
  message: false
editor_options:
  chunk_output_type: console
---

```{r}
#| label: setup
#| include: false

# no longer needed:
# knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


```{r}
library(tidyverse)
library(mdsr)
```

```{r}
# try out different shapes
test_data <- tibble(x = rexp(1000, rate = .1))    # mean = 1 / rate
test_data |>
  summarise(mean = mean(x),
            sd = sd(x))
ggplot(test_data, aes(x = x)) +
  geom_density()
# help("Distributions") for other shapes
```


```{r}
# could also focus on:
#  result$p.value
#  result$parameter (df)
#  width of CI
#  power to reject
#  different sample sizes
#  different shapes
```

Coverage of 95% confidence intervals

```{r}
# initial settings
mean1 <- 40
mean2 <- 40
truediff <- mean1 - mean2
sd1 <- 10
n1 <- 10
n2 <- 100
numsims <- 1000

coverage <- vector("double", 100)
for (j in 1:100)  {
sd_ratio <- j
sd2 <- sd_ratio * sd1

contains_truediff <- vector("logical", numsims)
for (i in 1:numsims) {
  samp1 <- rnorm(n1, mean1, sd1)
  samp2 <- rnorm(n2, mean2, sd2)
  result <- t.test(x = samp1, y = samp2)
  lower <- result$conf.int[1]
  upper <- result$conf.int[2]
  contains_truediff[i] <- (lower <= truediff & upper >= truediff)
}
coverage[j] <- mean(contains_truediff)
}

plotdata <- tibble(sd_ratio = 1:100, coverage = coverage)
ggplot(plotdata, aes(x = sd_ratio, y = coverage)) +
  geom_point() +
  geom_smooth(se = FALSE) +
  geom_hline(yintercept = .95)
```

Power of two-sample t-test

```{r}
power_calc <- function(truediff, sd1 = 10, sd2 = 10, 
                       n1 = 10, n2 = 10, numsims = 1000) {
  reject_null <- vector("logical", numsims)
  for (i in 1:numsims) {
    samp1 <- rnorm(n1, 0, sd1)
    samp2 <- rnorm(n2, 0 + truediff, sd2)
    result <- t.test(x = samp1, y = samp2)
    p_value <- result$p.value
    reject_null[i] <- (p_value < .05)
  }
  mean(reject_null)
}

power_calc(5)   # seems to work

true_diff <- seq(0, 30, length = 100)
power <- vector("double", length(true_diff))
for (j in 1:length(true_diff)) {
  power[j] <- power_calc(true_diff[j])
}

simdata <- tibble(true_diff = true_diff, power = power)
ggplot(simdata, aes(x = true_diff, y = power)) +
  geom_point() +
  geom_smooth(se = FALSE) +
  geom_hline(yintercept = .80, color = "red")
```

```{r}
# From MDSR
n <- 250
rmse <- 1
x1 <- rep(c(0, 1), each = n / 2) # x1 resembles 0 0 0 ... 1 1 1
beta0 <- -1
beta1 <- 0.5
beta2 <- 1.5

capture_beta1 <- vector("logical", 1000)
for (i in 1:1000) {
  x2 <- runif(n, min = 0, max = 10)
  y <- beta0 + beta1 * x1 + beta2 * x2 + rnorm(n, mean = 0, sd = rmse * x2)
  model1 <- lm(y ~ x1 + x2)
  lower <- confint(model1)[2,1]
  upper <- confint(model1)[2,2]
  capture_beta1[i] <- (lower < beta1 & upper > beta1)
}
#hist(beta1_hat)
#qqnorm(beta1_hat)
mean(capture_beta1)

```

```{r}
n <- 250
rmse <- 1
x1 <- rep(c(0, 1), each = n / 2) # x1 resembles 0 0 0 ... 1 1 1
x2 <- runif(n, min = 0, max = 5)
beta0 <- -1
beta1 <- 0.5
beta2 <- 1.5

capture_beta1 <- vector("logical", 1000)
beta1_hat <- vector("double", 1000)
for (i in 1:1000) {
  y <- beta0 + beta1 * x1 + beta2 * x2 + rexp(n, rate = 1 / 10)
  model1 <- lm(y ~ x1 + x2)
  beta1_hat[i] <- model1$coefficients[2]
  lower <- confint(model1)[2,1]
  upper <- confint(model1)[2,2]
  capture_beta1[i] <- (lower < beta1 & upper > beta1)
}
mean(capture_beta1)
hist(beta1_hat)
qqnorm(beta1_hat)
```

